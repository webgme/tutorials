/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 1.7.0 from webgme on Wed May 04 2016 23:18:45 GMT-0500 (CDT).
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'q',
    'plugin/FSMCodeGenerator/FSMCodeGenerator/FSMCodeGenerator'
], function (PluginConfig,
             pluginMetadata,
             PluginBase,
             Q,
             CodeGenerator) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of SignalMachineExplorer.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin SignalMachineExplorer.
     * @constructor
     */
    var SignalMachineExplorer = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    };

    function getNamespaceMeta(core, META, namespace) {
        var namespacedMeta = {},
            fullName,
            nodeNamespace;

        for (fullName in META) {
            nodeNamespace = core.getNamespace(META[fullName]);
            if (fullName.indexOf(namespace) === 0 && nodeNamespace.indexOf(namespace) === 0) {
                namespacedMeta[fullName.substr(namespace.length + 1)] = META[fullName];
            }
        }
        return namespacedMeta;
    }

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    SignalMachineExplorer.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    SignalMachineExplorer.prototype = Object.create(PluginBase.prototype);
    SignalMachineExplorer.prototype.constructor = SignalMachineExplorer;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    SignalMachineExplorer.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            nodeObject,
            codeGenerator = new CodeGenerator();

        codeGenerator.initialize(self.logger.fork('FSMCodeGenerator'), self.blobClient, self.gmeConfig);
        codeGenerator.configure(self); // this way we copy over the whole config

        //overriding some variables and methods
        codeGenerator.save = function (msg, cb) {
            console.log('internal plugins should not save on their own :D ');
            cb(null, this.result);
        };
        codeGenerator.META = getNamespaceMeta(self.core, self.META, 'FSM');

        nodeObject = self.activeNode;

        self.core.loadSubTree(nodeObject)
            .then(function (nodes) {
                var promises = [],
                    i,
                    metaTypeNode;

                for (i = 0; i < nodes.length; i += 1) {
                    metaTypeNode = self.core.getMetaType(nodes[i]);
                    // console.log(self.core.getFullyQualifiedName(self.core.getMetaType(nodes[i])));
                    // console.log(self.core.getNamespace(self.core.getMetaType(nodes[i])));
                    if (self.core.getNamespace(metaTypeNode) === 'FSM' &&
                        self.core.getAttribute(metaTypeNode, 'name') === 'StateMachine') {
                        promises.push(self.generateCodeForNode(nodes[i]));
                    }
                }

                return Q.allSettled(promises);
            })
            .then(function (results) {
                var i,
                    globalSuccess = true;

                for (i = 0; i < results.length; i += 1) {
                    if (results[i].status === 'rejected') {
                        self.logger.error(results[i].reason);
                        globalSuccess = false;
                    }
                }

                self.save('SignalMachineExplorer updated model.', function (err) {
                    if (err) {
                        callback(err, self.result);
                        return;
                    }
                    self.result.setSuccess(globalSuccess);
                    callback(null, self.result);
                });
            })
            .catch(function (err) {
                callback(err, self.result);
            });

    };

    SignalMachineExplorer.prototype.generateCodeForNode = function (node, callback) {
        var self = this,
            codeGenerator = new CodeGenerator(),
            deferred = Q.defer();

        codeGenerator.initialize(self.logger.fork('FSMCodeGenerator'), self.blobClient, self.gmeConfig);
        codeGenerator.configure(self); // this way we copy over the whole config from the initiating plugin

        //overriding some variables and methods
        codeGenerator.save = function (msg, cb) {
            if (typeof cb === 'function') {
                cb(null, this.result);
            }
        };
        codeGenerator.META = getNamespaceMeta(self.core, self.META, 'FSM');
        codeGenerator.activeNode = node;

        codeGenerator.main(function (err, result) {
            var i,
                artifacts;

            if (err) {
                deferred.reject(err);
                return;
            }

            if (result.getSuccess() === false) {
                self.logger.warn('code generation for node [' + self.core.getPath(node) + '] was not successfull');
                deferred.reject(new Error('Unsuccessful execution'));
                return;
            }

            // For now we just add the created artifacts to our own
            artifacts = result.getArtifacts();
            for (i = 0; i < artifacts.length; i += 1) {
                self.result.addArtifact(artifacts[i]);
            }

            deferred.resolve();
        });

        return deferred.promise.nodeify(callback);

    };

    return SignalMachineExplorer;
});